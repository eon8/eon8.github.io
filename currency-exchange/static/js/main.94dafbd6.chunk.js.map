{"version":3,"sources":["actions/converter.ts","actions/pockets.ts","reducers/converter.ts","core/pocket/Pocket.ts","actions/rates.ts","fetchers/fetchRates.ts","components/pocket-input/PocketInput.tsx","components/pocket/Pocket.tsx","components/converter/Converter.tsx","components/app/App.tsx","reducers/currencies.ts","reducers/pockets.ts","reducers/rates.ts","reducers/index.ts","store/index.ts","index.tsx"],"names":["PocketType","SELECT_POCKET","SET_AMOUNT","setAmounts","fromAmount","toAmount","valid","type","payload","POCKET_TOP_UP","POCKET_WITHDRAW","defaultFromAmount","defaultToAmount","initialConverterState","Pocket","currency","initBalance","balance","this","Decimal","toFixed","amount","delta","normalize","add","greaterThan","Error","sub","to","rate","mul","precision","sign","result","isNegative","FETCH_RATES_START","FETCH_RATES_SUCCESS","FETCH_RATES_FAIL","FETCH_RATES_STOP","timeout","DELAY","fetchRates","currencyCode","dispatch","getState","clearTimeout","fetchRatesStart","fetch","then","res","json","data","fetchRatesSuccess","rates","state","console","log","converter","from","code","setTimeout","fetchRatesStop","catch","error","fetchRatesFail","PocketInputPure","input","onChange","slot","event","updateAmounts","target","value","onKeyPress","charCode","props","propagateConvert","FROM","TO","slice","match","convert","getAmount","parseFloat","fromBalance","prevProps","prevState","snapshot","focus","balanceFormatted","format","className","onClick","change","renderValue","renderRate","invalid","ref","left","right","React","Component","mapDispatchToProps","PocketInput","connect","pockets","PocketPure","isChanging","renderOption","key","select","title","PocketModel","setState","document","addEventListener","close","stopPropagation","selectPocket","removeEventListener","currencies","map","ownProps","Object","values","undefined","ConverterPure","Converter","pocketTopUp","App","initialCurrenciesState","USD","EUR","GBP","JPY","CAD","IRatesFetchStatus","initialPocketsState","Math","random","initialRatesState","rootReducer","combineReducers","action","newState","initAmount","topUp","withdraw","status","FETCHING","PENDING","SLEEPING","store","createStore","applyMiddleware","thunk","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.94dafbd6.chunk.js","sourcesContent":["import { ICurrency } from \"../core/currency/Currency\";\n\nexport const SELECT_POCKET = \"SELECT_POCKET\";\nexport const SET_AMOUNT = \"SET_AMOUNT\";\n\nexport enum PocketType {\n  FROM = \"from\",\n  TO = \"to\"\n}\n\nexport interface ISelectPocket {\n  type: typeof SELECT_POCKET;\n  payload: {\n    slot: PocketType;\n    currency: ICurrency;\n  };\n}\n\nexport interface ISetAmount {\n  type: typeof SET_AMOUNT;\n  payload: {\n    fromAmount: string;\n    toAmount: string;\n    valid: boolean;\n  };\n}\n\nexport type IConverterAction = ISelectPocket | ISetAmount;\n\nexport function selectPocket(\n  slot: PocketType,\n  currency: ICurrency\n): ISelectPocket {\n  return {\n    type: SELECT_POCKET,\n    payload: {\n      slot,\n      currency\n    }\n  };\n}\n\nexport function setAmounts(\n  fromAmount: string,\n  toAmount: string,\n  valid: boolean\n): ISetAmount {\n  return {\n    type: SET_AMOUNT,\n    payload: {\n      fromAmount,\n      toAmount,\n      valid\n    }\n  };\n}\n","import { ICurrency } from \"../core/currency/Currency\";\n\nexport const POCKET_TOP_UP = \"POCKET_TOP_UP\";\nexport const POCKET_WITHDRAW = \"POCKET_WITHDRAW\";\n\nexport interface IPocketTopUp {\n  type: typeof POCKET_TOP_UP;\n  payload: {\n    currency: ICurrency;\n    amount: string;\n  };\n}\n\nexport interface IPocketWithdraw {\n  type: typeof POCKET_WITHDRAW;\n  payload: {\n    currency: ICurrency;\n    amount: string;\n  };\n}\n\nexport type IPocketsAction = IPocketTopUp | IPocketWithdraw;\n\nexport function pocketTopUp(currency: ICurrency, amount: string): IPocketTopUp {\n  return {\n    type: POCKET_TOP_UP,\n    payload: {\n      currency,\n      amount\n    }\n  };\n}\n\nexport function pocketWithdraw(\n  currency: ICurrency,\n  amount: string\n): IPocketWithdraw {\n  return {\n    type: POCKET_WITHDRAW,\n    payload: {\n      currency,\n      amount\n    }\n  };\n}\n","import {\n  IConverterAction,\n  PocketType,\n  SELECT_POCKET,\n  SET_AMOUNT\n} from \"../actions/converter\";\nimport { ICurrency } from \"../core/currency/Currency\";\n\nexport interface IConverterState {\n  from?: ICurrency;\n  to?: ICurrency;\n  fromAmount: string;\n  toAmount: string;\n  valid: boolean;\n}\n\nexport const defaultFromAmount = \"\";\nexport const defaultToAmount = \"0.00\";\n\nexport const initialConverterState: IConverterState = {\n  fromAmount: defaultFromAmount,\n  toAmount: defaultToAmount,\n  valid: false\n};\n\nexport default function converterReducer(\n  state: IConverterState = initialConverterState,\n  action: IConverterAction\n): IConverterState {\n  switch (action.type) {\n    case SELECT_POCKET: {\n      const { slot, currency } = action.payload;\n      let newState = state;\n\n      if (slot === PocketType.FROM) {\n        newState = {\n          ...state,\n          from: currency\n        };\n        if (state.to && state.to.code === currency.code) {\n          const { to, ...cleanState } = newState;\n          newState = cleanState;\n        }\n      } else {\n        newState = {\n          ...state,\n          to: currency\n        };\n        if (state.from && state.from.code === currency.code) {\n          const { from, ...cleanState } = newState;\n          newState = cleanState;\n        }\n      }\n\n      return {\n        ...newState,\n        fromAmount: defaultFromAmount,\n        toAmount: defaultToAmount\n      };\n    }\n\n    case SET_AMOUNT: {\n      const { fromAmount, toAmount, valid } = action.payload;\n      return { ...state, fromAmount, toAmount, valid };\n    }\n  }\n\n  return state;\n}\n","import Decimal from \"decimal.js\";\nimport { ICurrency } from \"../currency/Currency\";\n\nexport class Pocket {\n  private balance: Decimal;\n\n  constructor(private currency: ICurrency, initBalance?: string) {\n    this.balance = new Decimal(initBalance || \"0.00\");\n  }\n\n  public getType(): ICurrency {\n    return this.currency;\n  }\n\n  public getAmount(): string {\n    return this.balance.toFixed(2);\n  }\n\n  public topUp(amount: string): Pocket {\n    const delta = this.normalize(amount);\n    this.balance = this.balance.add(delta);\n    return this;\n  }\n\n  public withdraw(amount: string): Pocket {\n    const delta = this.normalize(amount);\n    if (delta.greaterThan(this.balance)) {\n      throw new Error(\"Amount is greater that balance\");\n    }\n    this.balance = this.balance.sub(delta);\n    return this;\n  }\n\n  public convert(to: ICurrency, rate: number): Pocket {\n    return new Pocket(to, this.balance.mul(rate).toFixed(2));\n  }\n\n  public format(precision: number = 2): string {\n    return `${this.currency.sign}${this.balance.toFixed(precision)}`;\n  }\n\n  private normalize(amount: string): Decimal {\n    const result = new Decimal(amount);\n    if (result.isNegative()) {\n      throw new Error(\"Amount cannot be negative\");\n    }\n    return result;\n  }\n}\n","export const FETCH_RATES_START = \"FETCH_RATES_START\";\nexport const FETCH_RATES_SUCCESS = \"FETCH_RATES_SUCCESS\";\nexport const FETCH_RATES_FAIL = \"FETCH_RATES_FAIL\";\nexport const FETCH_RATES_STOP = \"FETCH_RATES_STOP\";\n\nexport interface IFetchRatesStart {\n  type: typeof FETCH_RATES_START;\n  payload: {\n    currencyCode: string;\n  };\n}\n\nexport interface IFetchRatesSuccess {\n  type: typeof FETCH_RATES_SUCCESS;\n  payload: {\n    currencyCode: string;\n    data: Record<string, number>;\n  };\n}\n\nexport interface IFetchRatesFail {\n  type: typeof FETCH_RATES_FAIL;\n  payload: {\n    currencyCode: string;\n    error: string;\n  };\n}\n\nexport interface IFetchRatesStop {\n  type: typeof FETCH_RATES_STOP;\n  payload: {\n    currencyCode: string;\n  };\n}\n\nexport type IRatesAction =\n  | IFetchRatesStart\n  | IFetchRatesSuccess\n  | IFetchRatesFail\n  | IFetchRatesStop;\n\nexport function fetchRatesStart(currencyCode: string): IFetchRatesStart {\n  return {\n    type: FETCH_RATES_START,\n    payload: {\n      currencyCode\n    }\n  };\n}\n\nexport function fetchRatesSuccess(\n  currencyCode: string,\n  data: Record<string, number>\n): IFetchRatesSuccess {\n  return {\n    type: FETCH_RATES_SUCCESS,\n    payload: {\n      currencyCode,\n      data\n    }\n  };\n}\n\nexport function fetchRatesFail(\n  currencyCode: string,\n  error: string\n): IFetchRatesFail {\n  return {\n    type: FETCH_RATES_FAIL,\n    payload: {\n      currencyCode,\n      error\n    }\n  };\n}\n\nexport function fetchRatesStop(currencyCode: string): IFetchRatesStop {\n  return {\n    type: FETCH_RATES_STOP,\n    payload: {\n      currencyCode\n    }\n  };\n}\n","import { Dispatch } from \"redux\";\nimport {\n  fetchRatesFail,\n  fetchRatesStart,\n  fetchRatesStop,\n  fetchRatesSuccess\n} from \"../actions/rates\";\nimport { IStoreState } from \"../reducers\";\n\nconst DELAY = 10000;\nlet timeout: NodeJS.Timeout;\n\nfunction fetchRates(currencyCode: string) {\n  return (dispatch: Dispatch, getState: () => IStoreState) => {\n    clearTimeout(timeout);\n    dispatch(fetchRatesStart(currencyCode));\n\n    fetch(\"https://api.exchangeratesapi.io/latest?base=\" + currencyCode)\n      .then(res => res.json())\n      .then(res => {\n        dispatch(fetchRatesSuccess(currencyCode, res.rates));\n\n        const state: IStoreState = getState();\n        // tslint:disable-next-line:no-console\n        console.log(state);\n\n        if (\n          state.converter.from &&\n          state.converter.from.code === currencyCode\n        ) {\n          timeout = setTimeout(() => {\n            dispatch(fetchRates(currencyCode) as any);\n          }, DELAY);\n        } else {\n          dispatch(fetchRatesStop(currencyCode));\n        }\n      })\n      .catch(error => {\n        dispatch(fetchRatesFail(currencyCode, error));\n      });\n  };\n}\n\nexport default fetchRates;\n","import React from \"react\";\nimport { connect } from \"react-redux\";\nimport { PocketType, setAmounts } from \"../../actions/converter\";\nimport { ICurrency } from \"../../core/currency/Currency\";\nimport { Pocket } from \"../../core/pocket/Pocket\";\nimport { IStoreState } from \"../../reducers\";\nimport { IRatesData } from \"../../reducers/rates\";\nimport \"./PocketInput.css\";\n\ninterface IPocketInputStateProps {\n  from?: ICurrency;\n  to?: ICurrency;\n  fromBalance: string;\n  rate?: number;\n  fromAmount: string;\n  toAmount: string;\n  valid: boolean;\n}\n\ninterface IPocketInputDispatchProps {\n  setAmounts: typeof setAmounts;\n}\n\ninterface IPocketInputOwnProps {\n  slot: PocketType;\n  currency: ICurrency;\n  balance?: string;\n  change: () => void;\n  propagateConvert: () => void;\n}\n\ntype IPocketInputProps = IPocketInputStateProps &\n  IPocketInputDispatchProps &\n  IPocketInputOwnProps;\n\nexport class PocketInputPure extends React.Component<IPocketInputProps> {\n  input: HTMLInputElement | null = null;\n\n  componentDidUpdate(\n    prevProps: Readonly<IPocketInputProps>,\n    prevState: Readonly<{}>,\n    snapshot?: any\n  ): void {\n    if (\n      this.input &&\n      (prevProps.from !== this.props.from ||\n        prevProps.to !== this.props.to ||\n        prevProps.fromBalance !== this.props.fromBalance)\n    ) {\n      this.input.focus();\n    }\n  }\n\n  render() {\n    const { currency, balance } = this.props;\n    const balanceFormatted = new Pocket(currency, balance).format();\n    return (\n      <div className=\"PocketInput\">\n        <div className=\"PocketInput-top\">\n          <div\n            className=\"nowrap noshrink clickable\"\n            onClick={this.props.change}\n          >\n            {currency.code}\n          </div>\n          {this.renderValue()}\n        </div>\n        <div className=\"PocketInput-bottom\">\n          <span className=\"nowrap\">You have {balanceFormatted}</span>\n          {this.renderRate()}\n        </div>\n      </div>\n    );\n  }\n\n  renderValue() {\n    const { slot, from, to, rate, fromAmount, toAmount, valid } = this.props;\n    if (!from || !to || !rate) {\n      return null;\n    }\n\n    const invalid =\n      slot === PocketType.FROM && parseFloat(fromAmount) && !valid;\n\n    return (\n      <input\n        className={\"PocketInput-field\" + (invalid ? \" invalid\" : \"\")}\n        value={slot === PocketType.FROM ? fromAmount : toAmount}\n        onChange={this.onChange(slot)}\n        onKeyPress={this.onKeyPress}\n        ref={input => {\n          if (slot === PocketType.FROM) {\n            this.input = input;\n          }\n        }}\n      />\n    );\n  }\n\n  renderRate() {\n    const { slot, from, currency, rate } = this.props;\n    const showRate = slot === PocketType.TO && from && rate;\n    if (!showRate) {\n      return null;\n    }\n    const left = new Pocket(from!, \"1\").format(0);\n\n    const right = new Pocket(currency, `${rate}`).format(4);\n    return (\n      <span className=\"nowrap\">\n        {left} = {right}\n      </span>\n    );\n  }\n\n  onChange = (slot: PocketType) => (\n    event: React.ChangeEvent<HTMLInputElement>\n  ) => {\n    this.updateAmounts(slot, event.target.value);\n  };\n\n  onKeyPress = (event: React.KeyboardEvent) => {\n    if (event.charCode === 13) {\n      this.props.propagateConvert();\n    }\n  };\n\n  updateAmounts = (slot: PocketType, amount: string) => {\n    const regex = /^\\d+(\\.\\d{0,2})?$/;\n    const sign = {\n      [PocketType.FROM]: \"-\",\n      [PocketType.TO]: \"+\"\n    };\n    if (amount && amount[0] === sign[slot]) {\n      amount = amount.slice(1);\n    }\n    if (amount && amount[0] === \".\") {\n      amount = \"0.\" + amount.slice(1, 3);\n    }\n    if (amount && !amount.match(regex)) {\n      return;\n    }\n\n    let fromAmount;\n    let toAmount;\n\n    if (slot === PocketType.FROM) {\n      fromAmount = amount;\n      toAmount = new Pocket(this.props.from!, amount)\n        .convert(this.props.to!, this.props.rate!)\n        .getAmount();\n    } else {\n      toAmount = amount;\n      fromAmount = new Pocket(this.props.to!, amount)\n        .convert(this.props.from!, 1 / this.props.rate!)\n        .getAmount();\n    }\n\n    const valid =\n      parseFloat(fromAmount) > 0 &&\n      parseFloat(fromAmount) <= parseFloat(this.props.fromBalance);\n\n    this.props.setAmounts(fromAmount, toAmount, valid);\n  };\n}\n\nconst mapStateToProps = (state: IStoreState): IPocketInputStateProps => {\n  const { from, to, fromAmount, toAmount, valid } = state.converter;\n  const fromBalance = (from && state.pockets[from.code]) || \"0\";\n\n  let rate: number | undefined;\n  if (from && to) {\n    const rates: IRatesData = state.rates[from.code];\n    if (rates && rates.data && rates.data[to.code]) {\n      rate = rates.data[to.code];\n    }\n  }\n\n  return {\n    from,\n    to,\n    fromBalance,\n    rate,\n    fromAmount: fromAmount ? \"-\" + fromAmount : \"\",\n    toAmount: toAmount ? \"+\" + toAmount : \"\",\n    valid\n  };\n};\n\nconst mapDispatchToProps = {\n  setAmounts\n};\n\nconst PocketInput = connect<\n  IPocketInputStateProps,\n  IPocketInputDispatchProps,\n  IPocketInputOwnProps,\n  IStoreState\n>(\n  mapStateToProps,\n  mapDispatchToProps\n)(PocketInputPure);\n\nexport default PocketInput;\n","import React from \"react\";\nimport { connect } from \"react-redux\";\nimport { Dispatch } from \"redux\";\nimport { PocketType, selectPocket } from \"../../actions/converter\";\nimport { ICurrency } from \"../../core/currency/Currency\";\nimport { Pocket as PocketModel } from \"../../core/pocket/Pocket\";\nimport fetchRates from \"../../fetchers/fetchRates\";\nimport { IStoreState } from \"../../reducers\";\nimport { IPocketsState } from \"../../reducers/pockets\";\nimport PocketInput from \"../pocket-input/PocketInput\";\nimport \"./Pocket.css\";\n\ninterface IPocketStateProps {\n  pockets: IPocketsState;\n  currencies: ICurrency[];\n  currency?: ICurrency;\n  balance?: string;\n}\n\ninterface IPocketDispatchProps {\n  selectPocket: (slot: PocketType, currency: ICurrency) => void;\n}\n\ninterface IPocketOwnProps {\n  slot: PocketType;\n  propagateConvert: () => void;\n}\n\ntype IPocketProps = IPocketStateProps & IPocketDispatchProps & IPocketOwnProps;\n\ninterface IPocketState {\n  isChanging: boolean;\n}\n\nexport class PocketPure extends React.Component<IPocketProps, IPocketState> {\n  state: IPocketState = { isChanging: false };\n\n  render() {\n    const { isChanging } = this.state;\n    const {\n      slot,\n      currency,\n      currencies,\n      balance,\n      propagateConvert\n    } = this.props;\n    return (\n      <div className=\"Pocket\">\n        {isChanging ? (\n          <div className=\"Pocket-list\">{currencies.map(this.renderOption)}</div>\n        ) : currency ? (\n          <PocketInput\n            slot={slot}\n            currency={currency}\n            balance={balance}\n            change={this.change}\n            propagateConvert={propagateConvert}\n          />\n        ) : (\n          <div className=\"Pocket-select\" onClick={this.change}>\n            Select {slot === PocketType.FROM ? \"source\" : \"destination\"} pocket\n          </div>\n        )}\n      </div>\n    );\n  }\n\n  renderOption = (currency: ICurrency) => {\n    return (\n      <div\n        className=\"Pocket-list-item\"\n        key={currency.code}\n        onClick={this.select(currency)}\n      >\n        {currency.title}\n        &nbsp;\n        <small>\n          (\n          {new PocketModel(\n            currency,\n            this.props.pockets[currency.code]\n          ).format()}\n          )\n        </small>\n      </div>\n    );\n  };\n\n  change = () => {\n    this.setState({ isChanging: true });\n    document.addEventListener(\"click\", this.close);\n  };\n\n  select = (currency: ICurrency) => (event: React.MouseEvent) => {\n    event.stopPropagation();\n    this.props.selectPocket(this.props.slot, currency);\n    this.close();\n  };\n\n  close = () => {\n    this.setState({ isChanging: false });\n    document.removeEventListener(\"click\", this.close);\n  };\n}\n\nconst mapStateToProps = (\n  state: IStoreState,\n  ownProps: IPocketOwnProps\n): IPocketStateProps => {\n  const pockets = state.pockets;\n  const currencies = Object.values(state.currencies);\n  const currency = state.converter[ownProps.slot];\n  const balance = currency ? state.pockets[currency.code] : undefined;\n  return {\n    pockets,\n    currencies,\n    currency,\n    balance\n  };\n};\n\nconst mapDispatchToProps = (dispatch: Dispatch): IPocketDispatchProps => ({\n  selectPocket: (slot, currency) => {\n    dispatch(selectPocket(slot, currency));\n    if (slot === PocketType.FROM) {\n      dispatch(fetchRates(currency.code) as any);\n    }\n  }\n});\n\nconst Pocket = connect<\n  IPocketStateProps,\n  IPocketDispatchProps,\n  IPocketOwnProps,\n  IStoreState\n>(\n  mapStateToProps,\n  mapDispatchToProps\n)(PocketPure);\n\nexport default Pocket;\n","import React from \"react\";\nimport { connect } from \"react-redux\";\nimport { Dispatch } from \"redux\";\nimport { PocketType, setAmounts } from \"../../actions/converter\";\nimport { pocketTopUp, pocketWithdraw } from \"../../actions/pockets\";\nimport { ICurrency } from \"../../core/currency/Currency\";\nimport { IStoreState } from \"../../reducers\";\nimport { defaultFromAmount, defaultToAmount } from \"../../reducers/converter\";\nimport Pocket from \"../pocket/Pocket\";\nimport \"./Converter.css\";\n\nexport interface IConverterStateProps {\n  from?: ICurrency;\n  to?: ICurrency;\n  fromAmount: string;\n  toAmount: string;\n  valid: boolean;\n}\n\nexport interface IConverterDispatchProps {\n  convert: (\n    from: ICurrency,\n    to: ICurrency,\n    fromAmount: string,\n    toAmount: string\n  ) => void;\n}\n\nexport type IConverterProps = IConverterStateProps & IConverterDispatchProps;\n\nexport class ConverterPure extends React.Component<IConverterProps> {\n  render() {\n    const { valid } = this.props;\n    return (\n      <div>\n        <div className=\"Converter\">\n          <div className=\"Converter-line\">\n            <Pocket slot={PocketType.FROM} propagateConvert={this.convert} />\n          </div>\n          <div className=\"Converter-line\">\n            <Pocket slot={PocketType.TO} propagateConvert={this.convert} />\n          </div>\n        </div>\n        {valid ? (\n          <button className=\"Converter-button\" onClick={this.convert}>\n            Convert\n          </button>\n        ) : null}\n      </div>\n    );\n  }\n\n  convert = () => {\n    const { valid, from, to, fromAmount, toAmount } = this.props;\n    if (from && to && valid) {\n      this.props.convert(from, to, fromAmount, toAmount);\n    }\n  };\n}\n\nconst mapStateToProps = (state: IStoreState): IConverterStateProps => {\n  const { from, to, fromAmount, toAmount, valid } = state.converter;\n  return { from, to, fromAmount, toAmount, valid };\n};\n\nconst mapDispatchToProps = (dispatch: Dispatch): IConverterDispatchProps => ({\n  convert: (\n    from: ICurrency,\n    to: ICurrency,\n    fromAmount: string,\n    toAmount: string\n  ) => {\n    dispatch(pocketWithdraw(from, fromAmount));\n    dispatch(pocketTopUp(to, toAmount));\n    dispatch(setAmounts(defaultFromAmount, defaultToAmount, false));\n  }\n});\n\nconst Converter = connect(mapStateToProps, mapDispatchToProps)(ConverterPure);\n\nexport default Converter;\n","import React from \"react\";\nimport Converter from \"../converter/Converter\";\nimport \"./App.css\";\n\nconst App: React.FC = () => {\n  return (\n    <div className=\"App\">\n      <div className=\"App-header\">\n        <h1 className=\"App-title\">Exchange</h1>\n      </div>\n      <div className=\"App-body\">\n        <Converter />\n      </div>\n    </div>\n  );\n};\n\nexport default App;\n","import { IConverterAction } from \"../actions/converter\";\nimport { ICurrency } from \"../core/currency/Currency\";\n\nexport interface ICurrenciesState {\n  [currencyCode: string]: ICurrency;\n}\n\nexport const initialCurrenciesState: ICurrenciesState = {\n  USD: {\n    code: \"USD\",\n    sign: \"$\",\n    title: \"US dollar\"\n  },\n  EUR: {\n    code: \"EUR\",\n    sign: \"€\",\n    title: \"Euro\"\n  },\n  GBP: {\n    code: \"GBP\",\n    sign: \"£\",\n    title: \"Pound sterling\"\n  },\n  JPY: {\n    code: \"JPY\",\n    sign: \"¥\",\n    title: \"Japanese yen\"\n  },\n  CAD: {\n    code: \"CAD\",\n    sign: \"C$\",\n    title: \"Canadian dollar\"\n  }\n};\n\nexport default function currenciesReducer(\n  state: ICurrenciesState = initialCurrenciesState,\n  action: IConverterAction\n): ICurrenciesState {\n  return state;\n}\n","import {\n  IPocketsAction,\n  POCKET_TOP_UP,\n  POCKET_WITHDRAW\n} from \"../actions/pockets\";\nimport { Pocket } from \"../core/pocket/Pocket\";\n\nexport interface IPocketsState {\n  [currencyCode: string]: string;\n}\n\nexport const initialPocketsState: IPocketsState = {\n  USD: (Math.random() * 4900 + 100).toFixed(2),\n  EUR: (Math.random() * 3950 + 50).toFixed(2),\n  GBP: (Math.random() * 3000).toFixed(2)\n};\n\nexport default function pocketsReducer(\n  state: IPocketsState = initialPocketsState,\n  action: IPocketsAction\n): IPocketsState {\n  switch (action.type) {\n    case POCKET_TOP_UP: {\n      const { currency, amount } = action.payload;\n      const initAmount = state[currency.code];\n      return {\n        ...state,\n        [currency.code]: new Pocket(currency, initAmount)\n          .topUp(amount)\n          .getAmount()\n      };\n    }\n\n    case POCKET_WITHDRAW: {\n      const { currency, amount } = action.payload;\n      const initAmount = state[currency.code];\n      return {\n        ...state,\n        [currency.code]: new Pocket(currency, initAmount)\n          .withdraw(amount)\n          .getAmount()\n      };\n    }\n  }\n\n  return state;\n}\n","import {\n  FETCH_RATES_FAIL,\n  FETCH_RATES_START,\n  FETCH_RATES_STOP,\n  FETCH_RATES_SUCCESS,\n  IRatesAction\n} from \"../actions/rates\";\n\nexport enum IRatesFetchStatus {\n  FETCHING = \"fetching\",\n  PENDING = \"pending\",\n  SLEEPING = \"sleeping\"\n}\n\nexport interface IRatesData {\n  status: IRatesFetchStatus;\n  data?: Record<string, number>;\n  error?: string;\n}\n\nexport interface IRatesState {\n  [currencyCode: string]: IRatesData;\n}\n\nexport const initialRatesState: IRatesState = {};\n\nexport default function ratesReducer(\n  state: IRatesState = initialRatesState,\n  action: IRatesAction\n): IRatesState {\n  switch (action.type) {\n    case FETCH_RATES_START: {\n      const { currencyCode } = action.payload;\n      return {\n        ...state,\n        [currencyCode]: {\n          ...state[currencyCode],\n          status: IRatesFetchStatus.FETCHING\n        }\n      };\n    }\n\n    case FETCH_RATES_SUCCESS: {\n      const { currencyCode, data } = action.payload;\n      return {\n        ...state,\n        [currencyCode]: {\n          ...state[currencyCode],\n          status: IRatesFetchStatus.PENDING,\n          data\n        }\n      };\n    }\n\n    case FETCH_RATES_FAIL: {\n      const { currencyCode, error } = action.payload;\n      return {\n        ...state,\n        [currencyCode]: {\n          ...state[currencyCode],\n          status: IRatesFetchStatus.PENDING,\n          error\n        }\n      };\n    }\n\n    case FETCH_RATES_STOP: {\n      const { currencyCode } = action.payload;\n      return {\n        ...state,\n        [currencyCode]: {\n          ...state[currencyCode],\n          status: IRatesFetchStatus.SLEEPING,\n          error: undefined\n        }\n      };\n    }\n  }\n\n  return state;\n}\n","import { combineReducers } from \"redux\";\nimport { default as converter, IConverterState } from \"./converter\";\nimport { default as currencies, ICurrenciesState } from \"./currencies\";\nimport { default as pockets, IPocketsState } from \"./pockets\";\nimport { default as rates, IRatesState } from \"./rates\";\n\nexport interface IStoreState {\n  currencies: ICurrenciesState;\n  converter: IConverterState;\n  pockets: IPocketsState;\n  rates: IRatesState;\n}\n\nconst rootReducer = combineReducers<IStoreState>({\n  currencies,\n  converter,\n  pockets,\n  rates\n});\n\nexport default rootReducer;\n","import { applyMiddleware, createStore } from \"redux\";\nimport thunk from \"redux-thunk\";\nimport rootReducer from \"../reducers\";\n\nconst store = createStore(rootReducer, applyMiddleware(thunk));\n\nexport default store;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { Provider } from \"react-redux\";\nimport App from \"./components/app/App\";\nimport \"./index.css\";\nimport store from \"./store\";\n\nReactDOM.render(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}